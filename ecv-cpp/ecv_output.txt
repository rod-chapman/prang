--------------------Configuration: Default configuration--------------------
Verification Studio: Running C:\Escher\PDTool\CplusPlus\UsualChecks\Output\Distribution64-2010\EscherToolC.exe -ll=C++11 -ld=0 -lcs -lws -ls(c=8,w=16,s=16,i=16,l=32,g=32,f=32,d=64,x=64,p=16) -sc="C:\Escher\ecv;C:\Escher\ecv\standard" -z1 -el=3 -em=100 -st=4 -sb=C:\Escher\PDTool\ecv.pd -sr=C:\Escher\PDTool\rubric.pd -vt=200 -vb=15 -vw=0 -vm=1000 -vps=tex -q=0 -vus=html -vpl=0 -vul=0 -vrs=html -vrl=0 -eM=2 "C:\Escher\Customers\prang-cpp\prang.cpp"
Escher Tool Critical Systems Edition version 7.00.
Copyright (C) 2017 Escher Technologies Ltd. All rights reserved.
Reading pre-parsed file C:\Escher\PDTool\ecv.pdc ... 0 seconds
Binding builtin file ... 0 seconds
Reading pre-parsed file C:\Escher\PDTool\rubric.pdc ... 0 seconds
Binding rubric file ... 0 seconds
Parsing file C:\Escher\Customers\prang-cpp\prang.cpp ... 0 seconds
C:\Escher\Customers\prang-cpp\prang.cpp (6,8): Warning! '#undef' used (MISRA-C 2012 rule 20.5).
1168 lines processed in parsed files.
Building program dictionary ... 0 seconds
Binding type names ... 0 seconds
Building member dictionaries ... 0 seconds
Binding other names ... 0 seconds
C:\Escher\Customers\prang-cpp\prang.cpp (113,5): Warning! Unable to verify call to function 'printf' because it has a variable argument list (MISRA-C 2012 rule 17.1).
C:\Escher\Customers\prang-cpp\prang.cpp (119,9): Warning! Unable to verify call to function 'printf' because it has a variable argument list (MISRA-C 2012 rule 17.1).
Linking ... 0 seconds
Standardising ... 0 seconds
Analysing ... 0 seconds
Compacting memory ... 0 seconds

Verifying file 'C:\Escher\Customers\prang-cpp\prang.cpp' ...
Generating verification conditions ... 72 verification conditions generated
Proving verification conditions ... confirmed 65, unprovable 3, too hard 4 (90.2% confirmed, longest 7.9 seconds)
240 seconds
C:\Escher\Customers\prang-cpp\prang.cpp (60,18): Information! Confirmed: Precondition of 'div' satisfied (defined at C:\Escher\ecv\standard\stdlib.h (94,10)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: 0 < static_cast<int>(a1$funcstart_1032,1$).
C:\Escher\Customers\prang-cpp\prang.cpp (61,20): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (operator*(heapIs $heap$funcstart_1032,1$, this).p1 < a1$funcstart_1032,1$) => (div1.rem == operator*(heapIs $heap$funcstart_1032,1$, this).p1).
C:\Escher\Customers\prang-cpp\prang.cpp (61,48): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (a1$funcstart_1032,1$ <= operator*(heapIs $heap$funcstart_1032,1$, this).p1) => !(0 == div1.quot).
C:\Escher\Customers\prang-cpp\prang.cpp (62,26): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !(0 == div1.rem) || !(0 == div1.quot).
C:\Escher\Customers\prang-cpp\prang.cpp (64,18): Information! Confirmed: Precondition of 'div' satisfied (defined at C:\Escher\ecv\standard\stdlib.h (94,10)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: 0 < static_cast<int>(a2$funcstart_1032,1$).
C:\Escher\Customers\prang-cpp\prang.cpp (65,20): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (operator*(heapIs $heap$funcstart_1032,1$, this).p2 < a2$funcstart_1032,1$) => (div2.rem == operator*(heapIs $heap$funcstart_1032,1$, this).p2).
C:\Escher\Customers\prang-cpp\prang.cpp (65,48): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (a2$funcstart_1032,1$ <= operator*(heapIs $heap$funcstart_1032,1$, this).p2) => !(0 == div2.quot).
C:\Escher\Customers\prang-cpp\prang.cpp (66,26): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !(0 == div2.rem) || !(0 == div2.quot).
C:\Escher\Customers\prang-cpp\prang.cpp (68,18): Information! Confirmed: Precondition of 'div' satisfied (defined at C:\Escher\ecv\standard\stdlib.h (94,10)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: 0 < static_cast<int>(a3$funcstart_1032,1$).
C:\Escher\Customers\prang-cpp\prang.cpp (69,20): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (operator*(heapIs $heap$funcstart_1032,1$, this).p3 < a3$funcstart_1032,1$) => (div3.rem == operator*(heapIs $heap$funcstart_1032,1$, this).p3).
C:\Escher\Customers\prang-cpp\prang.cpp (69,48): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (a3$funcstart_1032,1$ <= operator*(heapIs $heap$funcstart_1032,1$, this).p3) => !(0 == div3.quot).
C:\Escher\Customers\prang-cpp\prang.cpp (70,26): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !(0 == div3.rem) || !(0 == div3.quot).
C:\Escher\Customers\prang-cpp\prang.cpp (74,30): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (r1$funcstart_1032,1$ * static_cast<signed int>(div1.rem)) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (74,30): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (r1$funcstart_1032,1$ * static_cast<signed int>(div1.rem)).
C:\Escher\Customers\prang-cpp\prang.cpp (74,52): Information! Confirmed: Arithmetic result of operator '-' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((r1$funcstart_1032,1$ * static_cast<signed int>(div1.rem)) - (b1$funcstart_1032,1$ * static_cast<signed int>(div1.quot))).
C:\Escher\Customers\prang-cpp\prang.cpp (74,52): Information! Confirmed: Arithmetic result of operator '-' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((r1$funcstart_1032,1$ * static_cast<signed int>(div1.rem)) - (b1$funcstart_1032,1$ * static_cast<signed int>(div1.quot))) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (74,57): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (b1$funcstart_1032,1$ * static_cast<signed int>(div1.quot)).
C:\Escher\Customers\prang-cpp\prang.cpp (74,57): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (b1$funcstart_1032,1$ * static_cast<signed int>(div1.quot)) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (75,16): Information! Confirmed: Arithmetic result of operator '+' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) + temp1).
C:\Escher\Customers\prang-cpp\prang.cpp (75,16): Information! Confirmed: Arithmetic result of operator '+' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) + temp1) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (75,16): Information! Confirmed: Type constraint satisfied in implicit conversion from 'signed int' to 'P1Type' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) + temp1).
C:\Escher\Customers\prang-cpp\prang.cpp (75,16): Information! Confirmed: Type constraint satisfied in implicit conversion from 'signed int' to 'P1Type' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) + temp1) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (75,16): Warning! Exceeded boredom threshold proving: Type constraint satisfied in implicit conversion from 'signed int' to 'P1Type' (defined at C:\Escher\Customers\prang-cpp\prang.cpp (43,41)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#27), did not prove: (0 < ((M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) + temp1)) && (((M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) + temp1) < class WHPrang::M1).
	Suggestion: Add extra precondition or class invariant: (0 < ((-2 * div((*this).p1, 177).quot) + (171 * div((*this).p1, 177).rem))) && (-30268 <= ((-171 * div((*this).p1, 177).rem) + (2 * div((*this).p1, 177).quot)))
C:\Escher\Customers\prang-cpp\prang.cpp (75,18): Information! Confirmed: Type constraint satisfied in explicit conversion from 'integer' to 'int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0) <= maxof(int).
C:\Escher\Customers\prang-cpp\prang.cpp (75,18): Information! Confirmed: Type constraint satisfied in explicit conversion from 'integer' to 'int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(int) <= static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0).
C:\Escher\Customers\prang-cpp\prang.cpp (75,32): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))).
C:\Escher\Customers\prang-cpp\prang.cpp (75,32): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (M1$funcstart_1032,1$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$funcstart_1032,1$, this).p1 < (int)0))) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (77,30): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (r2$1032,1;1051,8$ * static_cast<signed int>(div2.rem)) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (77,30): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (r2$1032,1;1051,8$ * static_cast<signed int>(div2.rem)).
C:\Escher\Customers\prang-cpp\prang.cpp (77,52): Information! Confirmed: Arithmetic result of operator '-' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((r2$1032,1;1051,8$ * static_cast<signed int>(div2.rem)) - (b2$1032,1;1051,8$ * static_cast<signed int>(div2.quot))).
C:\Escher\Customers\prang-cpp\prang.cpp (77,52): Information! Confirmed: Arithmetic result of operator '-' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((r2$1032,1;1051,8$ * static_cast<signed int>(div2.rem)) - (b2$1032,1;1051,8$ * static_cast<signed int>(div2.quot))) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (77,57): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (b2$1032,1;1051,8$ * static_cast<signed int>(div2.quot)).
C:\Escher\Customers\prang-cpp\prang.cpp (77,57): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (b2$1032,1;1051,8$ * static_cast<signed int>(div2.quot)) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (78,16): Information! Confirmed: Arithmetic result of operator '+' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) + temp2).
C:\Escher\Customers\prang-cpp\prang.cpp (78,16): Information! Confirmed: Arithmetic result of operator '+' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) + temp2) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (78,16): Information! Confirmed: Type constraint satisfied in implicit conversion from 'signed int' to 'P2Type' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) + temp2).
C:\Escher\Customers\prang-cpp\prang.cpp (78,16): Information! Confirmed: Type constraint satisfied in implicit conversion from 'signed int' to 'P2Type' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) + temp2) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (78,16): Warning! Exceeded boredom threshold proving: Type constraint satisfied in implicit conversion from 'signed int' to 'P2Type' (defined at C:\Escher\Customers\prang-cpp\prang.cpp (44,41)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#42), did not prove: (0 < ((M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) + temp2)) && (((M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) + temp2) < class WHPrang::M2).
	Suggestion: Add extra precondition or class invariant: (0 < ((-35 * div((*this).p2, 176).quot) + (172 * div((*this).p2, 176).rem))) && (-30306 <= ((-172 * div((*this).p2, 176).rem) + (35 * div((*this).p2, 176).quot)))
C:\Escher\Customers\prang-cpp\prang.cpp (78,18): Information! Confirmed: Type constraint satisfied in explicit conversion from 'integer' to 'int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0) <= maxof(int).
C:\Escher\Customers\prang-cpp\prang.cpp (78,18): Information! Confirmed: Type constraint satisfied in explicit conversion from 'integer' to 'int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(int) <= static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0).
C:\Escher\Customers\prang-cpp\prang.cpp (78,32): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))).
C:\Escher\Customers\prang-cpp\prang.cpp (78,32): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (M2$1032,1;1051,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1051,8$, this).p2 < (int)0))) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (80,30): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (r3$1032,1;1054,8$ * static_cast<signed int>(div3.rem)) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (80,30): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (r3$1032,1;1054,8$ * static_cast<signed int>(div3.rem)).
C:\Escher\Customers\prang-cpp\prang.cpp (80,52): Information! Confirmed: Arithmetic result of operator '-' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((r3$1032,1;1054,8$ * static_cast<signed int>(div3.rem)) - (b3$1032,1;1054,8$ * static_cast<signed int>(div3.quot))).
C:\Escher\Customers\prang-cpp\prang.cpp (80,52): Information! Confirmed: Arithmetic result of operator '-' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((r3$1032,1;1054,8$ * static_cast<signed int>(div3.rem)) - (b3$1032,1;1054,8$ * static_cast<signed int>(div3.quot))) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (80,57): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (b3$1032,1;1054,8$ * static_cast<signed int>(div3.quot)).
C:\Escher\Customers\prang-cpp\prang.cpp (80,57): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (b3$1032,1;1054,8$ * static_cast<signed int>(div3.quot)) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (81,16): Information! Confirmed: Arithmetic result of operator '+' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) + temp3).
C:\Escher\Customers\prang-cpp\prang.cpp (81,16): Information! Confirmed: Arithmetic result of operator '+' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) + temp3) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (81,16): Information! Confirmed: Type constraint satisfied in implicit conversion from 'signed int' to 'P3Type' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= ((M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) + temp3).
C:\Escher\Customers\prang-cpp\prang.cpp (81,16): Information! Confirmed: Type constraint satisfied in implicit conversion from 'signed int' to 'P3Type' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: ((M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) + temp3) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (81,16): Warning! Exceeded boredom threshold proving: Type constraint satisfied in implicit conversion from 'signed int' to 'P3Type' (defined at C:\Escher\Customers\prang-cpp\prang.cpp (45,41)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#57), did not prove: (0 < ((M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) + temp3)) && (((M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) + temp3) < class WHPrang::M3).
	Suggestion: Add extra precondition or class invariant: (0 < ((-63 * div((*this).p3, 178).quot) + (170 * div((*this).p3, 178).rem))) && (-30322 <= ((-170 * div((*this).p3, 178).rem) + (63 * div((*this).p3, 178).quot)))
C:\Escher\Customers\prang-cpp\prang.cpp (81,18): Information! Confirmed: Type constraint satisfied in explicit conversion from 'integer' to 'int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0) <= maxof(int).
C:\Escher\Customers\prang-cpp\prang.cpp (81,18): Information! Confirmed: Type constraint satisfied in explicit conversion from 'integer' to 'int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(int) <= static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0).
C:\Escher\Customers\prang-cpp\prang.cpp (81,32): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: minof(signed int) <= (M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))).
C:\Escher\Customers\prang-cpp\prang.cpp (81,32): Information! Confirmed: Arithmetic result of operator '*' is within limit of type 'signed int' in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (M3$1032,1;1054,8$ * static_cast<int>(static_cast<integer>(operator*(heapIs $heap$1032,1;1054,8$, this).p3 < (int)0))) <= maxof(signed int).
C:\Escher\Customers\prang-cpp\prang.cpp (88,30): Information! Confirmed: Precondition of 'operator /' satisfied (defined at built in declaration) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !(0.0 == static_cast<double>(static_cast<real>(M1$funcend_1032,1$))).
C:\Escher\Customers\prang-cpp\prang.cpp (89,30): Information! Confirmed: Precondition of 'operator /' satisfied (defined at built in declaration) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !(0.0 == static_cast<double>(static_cast<real>(M2$funcend_1032,1$))).
C:\Escher\Customers\prang-cpp\prang.cpp (90,30): Information! Confirmed: Precondition of 'operator /' satisfied (defined at built in declaration) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !(0.0 == static_cast<double>(static_cast<real>(M3$funcend_1032,1$))).
C:\Escher\Customers\prang-cpp\prang.cpp (92,12): Warning! Unable to prove: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#63), did not prove: (double)0.0 < raux1.
	Suggestion: Add extra precondition or class invariant: 0.0 < (real((-2 * div((*this).p1, 177).quot) + (171 * div((*this).p1, 177).rem)) / 30269.0)
C:\Escher\Customers\prang-cpp\prang.cpp (92,25): Warning! Unable to prove: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#62), did not prove: (double)0.0 < raux2.
	Suggestion: Add extra precondition or class invariant: 0.0 < (real((-35 * div((*this).p2, 176).quot) + (172 * div((*this).p2, 176).rem)) / 30307.0)
C:\Escher\Customers\prang-cpp\prang.cpp (92,38): Warning! Unable to prove: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#61), did not prove: (double)0.0 < raux3.
	Suggestion: Add extra precondition or class invariant: 0.0 < (real((-63 * div((*this).p3, 178).quot) + (170 * div((*this).p3, 178).rem)) / 30323.0)
C:\Escher\Customers\prang-cpp\prang.cpp (94,26): Information! Confirmed: Assertion valid in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: (double)0.0 < (raux3 + raux2 + raux1).
C:\Escher\Customers\prang-cpp\prang.cpp (95,21): Information! Confirmed: Precondition of 'fmod' satisfied (defined at C:\Escher\ecv\standard\math.h (84,16)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: !((double)1.0 == (double)0.0).
C:\Escher\Customers\prang-cpp\prang.cpp (97,5): Information! Confirmed: Postcondition satisfied when function 'GetRandom' returns (defined at C:\Escher\Customers\prang-cpp\prang.cpp (25,33)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)], proved: result < (double)1.0.
C:\Escher\Customers\prang-cpp\prang.cpp (97,5): Warning! Exceeded boredom threshold proving: Postcondition satisfied when function 'GetRandom' returns (defined at C:\Escher\Customers\prang-cpp\prang.cpp (25,14)) in context of class WHPrang [C:\Escher\Customers\prang-cpp\prang.cpp (18,1)] (see C:\Escher\Customers\prang-cpp\prang_unproven.html#66), did not prove: (double)0.0 < result.
C:\Escher\Customers\prang-cpp\prang.cpp (115,5): Information! Confirmed: Loop initialisation establishes end condition or a valid variant (defined at C:\Escher\Customers\prang-cpp\prang.cpp (117,20)), proved: 0 <= (limit - count).
C:\Escher\Customers\prang-cpp\prang.cpp (118,5): Information! Confirmed: Loop body establishes end condition or preserves validity of variant (defined at C:\Escher\Customers\prang-cpp\prang.cpp (117,20)), proved: 0 <= (limit - count$loopend$).
C:\Escher\Customers\prang-cpp\prang.cpp (118,5): Information! Confirmed: Loop body establishes end condition or decreases variant (defined at C:\Escher\Customers\prang-cpp\prang.cpp (117,5)), proved: (limit - count$loopend$) < (limit - count$loopstart_1088,5$).
C:\Escher\Customers\prang-cpp\prang.cpp (120,9): Information! Confirmed: Arithmetic result of operator '++' is within limit of type 'int', proved: ++count$loopstart_1088,5$ <= maxof(int).
C:\Escher\Customers\prang-cpp\prang.cpp (120,9): Information! Confirmed: Arithmetic result of operator '++' is within limit of type 'int', proved: minof(int) <= ++count$loopstart_1088,5$.
Generating verification output files ... 1 second
0 errors, 10 warnings found.
Verification Studio: Job completed but warnings were detected!

